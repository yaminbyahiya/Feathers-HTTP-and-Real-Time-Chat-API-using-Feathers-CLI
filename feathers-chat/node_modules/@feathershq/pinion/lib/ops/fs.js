"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeJSON = exports.writeJSON = exports.loadJSON = exports.copyFiles = exports.fromFile = exports.toFile = void 0;
const path_1 = require("path");
const promises_1 = require("fs/promises");
const core_1 = require("../core");
const helpers_1 = require("./helpers");
const utils_1 = require("../utils");
const fileName = (createFolders = false) => (...targets) => async (ctx) => {
    const segments = (await (0, core_1.mapCallables)(targets, ctx)).flat();
    const fullPath = (0, path_1.resolve)(ctx.cwd, ...segments);
    if (createFolders) {
        await (0, promises_1.mkdir)((0, path_1.dirname)(fullPath), {
            recursive: true
        });
    }
    return fullPath;
};
exports.toFile = fileName(true);
exports.fromFile = fileName();
/**
 * Recursively copy all files from a folder to a destination.
 * Will prompt if the to file already exists.
 *
 * @param from The (local) folder to copy files from
 * @param to The destination to copy the files to
 * @param options File copy options (e.g. `{ force: true }`)
 * @returns The current context
 */
const copyFiles = (from, to, options = {}) => async (ctx) => {
    const source = await (0, core_1.getCallable)(from, ctx);
    const target = await (0, core_1.getCallable)(to, ctx);
    const fileList = await (0, utils_1.listAllFiles)(source);
    await Promise.all(fileList.map(async (file) => {
        const destination = (0, path_1.join)(target, (0, path_1.relative)(source, file));
        await (0, promises_1.mkdir)((0, path_1.dirname)(destination), {
            recursive: true
        });
        if (await (0, helpers_1.overwrite)(ctx, destination, options)) {
            await (0, promises_1.copyFile)(file, destination);
        }
    }));
    return (0, helpers_1.addTrace)(ctx, 'copyFiles', { fileList, target, source });
};
exports.copyFiles = copyFiles;
/**
 * Load a JSON file and merge the data into the context
 *
 * @param file The name of the JSON file
 * @param converter A converter that returns the data that will be merged into the context
 * @returns The current context
 */
const loadJSON = (file, converter = (data) => data, fallback) => async (ctx) => {
    const fileName = await (0, core_1.getCallable)(file, ctx);
    let data;
    try {
        const content = (await (0, promises_1.readFile)(fileName)).toString();
        data = JSON.parse(content);
    }
    catch (error) {
        if (fallback) {
            data = await (0, core_1.getCallable)(fallback, ctx);
        }
        else {
            throw error;
        }
    }
    const converted = await converter(data, ctx);
    const result = {
        ...ctx,
        ...converted
    };
    return (0, helpers_1.addTrace)(result, 'loadJSON', { fileName, data });
};
exports.loadJSON = loadJSON;
/**
 * Write formatted JSON to a file
 *
 * @param json The JSON data to write
 * @param file The filename to write to
 * @returns The current context
 */
const writeJSON = (json, file, options = {}) => async (ctx) => {
    const fileName = await (0, core_1.getCallable)(file, ctx);
    const data = await (0, core_1.getCallable)(json, ctx);
    const content = JSON.stringify(data, null, '  ');
    const result = await (0, helpers_1.promptWriteFile)(fileName, content, ctx, options);
    return (0, helpers_1.addTrace)(result, 'writeJSON', { fileName, data });
};
exports.writeJSON = writeJSON;
/**
 * Merge an existing JSON file with new data
 *
 * @param json The JSON data to add to the file
 * @param file The filename to write to
 * @returns The current context
 */
const mergeJSON = (json, file) => async (ctx) => {
    const fileName = await (0, core_1.getCallable)(file, ctx);
    const payload = await (0, core_1.getCallable)(json, ctx);
    const existingContent = (await (0, promises_1.readFile)(fileName)).toString();
    const data = (0, utils_1.merge)(JSON.parse(existingContent), payload);
    const content = JSON.stringify(data, null, '  ');
    await (0, promises_1.writeFile)(fileName, content);
    return (0, helpers_1.addTrace)(ctx, 'mergeJSON', { fileName, payload });
};
exports.mergeJSON = mergeJSON;
