"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.append = exports.prepend = exports.after = exports.before = exports.inject = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const promises_1 = require("fs/promises");
const core_1 = require("../core");
const os_1 = require("os");
const helpers_1 = require("./helpers");
const EOLRegex = /\r?\n/;
const inject = (template, location, target) => async (ctx) => {
    const fileName = await (0, core_1.getCallable)(target, ctx);
    const content = await (0, core_1.getCallable)(template, ctx);
    const relativeName = (0, path_1.relative)(ctx.cwd, fileName);
    if (!(0, fs_1.existsSync)(fileName)) {
        throw new Error(`Cannot inject to '${fileName}'. The file doesn't exist.`);
    }
    const fileContent = (await (0, promises_1.readFile)(fileName)).toString();
    const NL = newline(fileContent);
    const lines = fileContent.split(NL);
    const { index } = await location(lines, ctx, relativeName);
    if (index >= 0) {
        lines.splice(index, 0, content);
    }
    const newContent = lines.join(NL);
    await (0, promises_1.writeFile)(fileName, newContent);
    ctx.pinion.logger.notice(`Updated ${relativeName}`);
    return (0, helpers_1.addTrace)(ctx, 'inject', { fileName, content });
};
exports.inject = inject;
const escapeString = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
const getLineNumber = (pattern, lines, isBefore) => {
    const matcher = pattern instanceof RegExp ? pattern : new RegExp(escapeString(pattern), 'm');
    const oneLineMatchIndex = lines.findIndex((l) => l.match(matcher));
    if (oneLineMatchIndex < 0) {
        const fullText = lines.join('\n');
        const fullMatch = fullText.match(matcher);
        if (fullMatch && fullMatch.length) {
            if (isBefore) {
                const fullTextUntilMatchStart = fullText.substring(0, fullMatch.index);
                return fullTextUntilMatchStart.split(EOLRegex).length - 1;
            }
            const matchEndIndex = (fullMatch.index || 0) + fullMatch.toString().length;
            const fullTextUntilMatchEnd = fullText.substring(0, matchEndIndex);
            return fullTextUntilMatchEnd.split(EOLRegex).length;
        }
        return oneLineMatchIndex;
    }
    return oneLineMatchIndex + (isBefore ? 0 : 1);
};
const before = (pattern) => async (lines, ctx, fileName) => {
    const line = await (0, core_1.getCallable)(pattern, ctx);
    const index = getLineNumber(line, lines, true);
    if (index < 0) {
        throw new Error(`Could not find line '${line}' in file ${fileName} to inject content before`);
    }
    return { index, pattern: line };
};
exports.before = before;
const after = (pattern) => async (lines, ctx, fileName) => {
    const line = await (0, core_1.getCallable)(pattern, ctx);
    const index = getLineNumber(line, lines, false);
    if (index < 0) {
        throw new Error(`Could not find line '${line}' in file ${fileName} to inject content after`);
    }
    return { index, pattern: line };
};
exports.after = after;
const prepend = () => async () => {
    return { index: 0 };
};
exports.prepend = prepend;
const append = () => async (lines) => {
    return { index: lines.length };
};
exports.append = append;
const newline = (str) => {
    const newlines = str.match(/(?:\r?\n)/g) || [];
    if (newlines.length === 0) {
        return os_1.EOL;
    }
    const crlf = newlines.filter((newline) => newline === '\r\n').length;
    const lf = newlines.length - crlf;
    return crlf > lf ? '\r\n' : '\n';
};
