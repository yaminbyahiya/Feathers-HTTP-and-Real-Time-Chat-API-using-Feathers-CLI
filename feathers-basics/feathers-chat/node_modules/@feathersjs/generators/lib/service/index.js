"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = void 0;
const lodash_1 = __importDefault(require("lodash"));
const pinion_1 = require("@feathershq/pinion");
const commons_1 = require("../commons");
const chalk_1 = __importDefault(require("chalk"));
const generate = (ctx) => (0, pinion_1.generator)(ctx)
    .then((0, commons_1.initializeBaseContext)())
    .then((0, commons_1.checkPreconditions)())
    .then((0, pinion_1.prompt)(({ name, path, type, schema, authentication, isEntityService, feathers, lib, language }) => {
    const sqlDisabled = commons_1.DATABASE_TYPES.every((name) => name === 'mongodb' || name === 'other' || !(0, commons_1.fileExists)(lib, `${name}.${language}`));
    const mongodbDisabled = !(0, commons_1.fileExists)(lib, `mongodb.${language}`);
    return [
        {
            name: 'name',
            type: 'input',
            when: !name,
            message: 'What is the name of your service?',
            validate: (input) => {
                if (!input || input === 'authentication') {
                    return 'Invalid service name';
                }
                return true;
            }
        },
        {
            name: 'path',
            type: 'input',
            when: !path,
            message: 'Which path should the service be registered on?',
            default: (answers) => `${lodash_1.default.kebabCase(answers.name)}`,
            validate: (input) => {
                if (!input || input === 'authentication') {
                    return 'Invalid service path';
                }
                return true;
            }
        },
        {
            name: 'authentication',
            type: 'confirm',
            when: authentication === undefined && !isEntityService,
            message: 'Does this service require authentication?'
        },
        {
            name: 'type',
            type: 'list',
            when: !type,
            message: 'What database is the service using?',
            default: (0, commons_1.getDatabaseAdapter)(feathers === null || feathers === void 0 ? void 0 : feathers.database),
            choices: [
                {
                    value: 'knex',
                    name: `SQL${sqlDisabled ? chalk_1.default.gray(' (connection not available)') : ''}`,
                    disabled: sqlDisabled
                },
                {
                    value: 'mongodb',
                    name: `MongoDB${mongodbDisabled ? chalk_1.default.gray(' (connection not available)') : ''}`,
                    disabled: mongodbDisabled
                },
                {
                    value: 'custom',
                    name: 'A custom service'
                }
            ]
        },
        {
            name: 'schema',
            type: 'list',
            when: schema === undefined,
            message: 'Which schema definition format do you want to use?',
            suffix: chalk_1.default.grey(' Schemas allow to type, validate, secure and populate data'),
            default: feathers === null || feathers === void 0 ? void 0 : feathers.schema,
            choices: (answers) => [
                {
                    value: 'typebox',
                    name: `TypeBox ${chalk_1.default.gray(' (recommended)')}`
                },
                {
                    value: 'json',
                    name: 'JSON schema'
                },
                {
                    value: false,
                    name: `No schema${answers.type !== 'custom' ? chalk_1.default.gray(' (not recommended with a database)') : ''}`
                }
            ]
        }
    ];
}))
    .then(async (ctx) => {
    const { name, path, type, authStrategies = [] } = ctx;
    const kebabName = lodash_1.default.kebabCase(name);
    const camelName = lodash_1.default.camelCase(name);
    const upperName = lodash_1.default.upperFirst(camelName);
    const className = `${upperName}Service`;
    const folder = path.split('/').filter((el) => el !== '');
    const relative = ['', ...folder].map(() => '..').join('/');
    const fileName = lodash_1.default.last(folder);
    const kebabPath = lodash_1.default.kebabCase(path);
    return {
        name,
        type,
        path,
        folder,
        fileName,
        upperName,
        className,
        kebabName,
        camelName,
        kebabPath,
        relative,
        authStrategies,
        ...ctx
    };
})
    .then((0, pinion_1.runGenerators)(__dirname, 'templates'))
    .then((0, pinion_1.runGenerator)(__dirname, 'type', ({ type }) => `${type}.tpl`));
exports.generate = generate;
//# sourceMappingURL=index.js.map