"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoDbAdapter = void 0;
const mongodb_1 = require("mongodb");
const errors_1 = require("@feathersjs/errors");
const commons_1 = require("@feathersjs/commons");
const adapter_commons_1 = require("@feathersjs/adapter-commons");
const error_handler_1 = require("./error-handler");
// Create the service.
class MongoDbAdapter extends adapter_commons_1.AdapterBase {
    constructor(options) {
        if (!options) {
            throw new Error('MongoDB options have to be provided');
        }
        super({
            id: '_id',
            ...options
        });
    }
    getObjectId(id) {
        if (this.options.disableObjectify) {
            return id;
        }
        if (this.id === '_id' && mongodb_1.ObjectId.isValid(id)) {
            id = new mongodb_1.ObjectId(id.toString());
        }
        return id;
    }
    filterQuery(id, params) {
        const options = this.getOptions(params);
        const { $select, $sort, $limit: _limit, $skip = 0, ...query } = (params.query || {});
        const $limit = (0, adapter_commons_1.getLimit)(_limit, options.paginate);
        if (id !== null) {
            query.$and = (query.$and || []).concat({
                [this.id]: this.getObjectId(id)
            });
        }
        if (query[this.id]) {
            query[this.id] = this.getObjectId(query[this.id]);
        }
        return {
            filters: { $select, $sort, $limit, $skip },
            query
        };
    }
    getModel(params = {}) {
        const { Model } = this.getOptions(params);
        return Promise.resolve(Model);
    }
    async findRaw(params) {
        const { filters, query } = this.filterQuery(null, params);
        const model = await this.getModel(params);
        const q = model.find(query, { ...params.mongodb });
        if (filters.$select !== undefined) {
            q.project(this.getSelect(filters.$select));
        }
        if (filters.$sort !== undefined) {
            q.sort(filters.$sort);
        }
        if (filters.$skip !== undefined) {
            q.skip(filters.$skip);
        }
        if (filters.$limit !== undefined) {
            q.limit(filters.$limit);
        }
        return q;
    }
    async aggregateRaw(params) {
        const model = await this.getModel(params);
        const pipeline = params.pipeline || [];
        const index = pipeline.findIndex((stage) => stage.$feathers);
        const before = index >= 0 ? pipeline.slice(0, index) : [];
        const feathersPipeline = this.makeFeathersPipeline(params);
        const after = index >= 0 ? pipeline.slice(index + 1) : pipeline;
        return model.aggregate([...before, ...feathersPipeline, ...after]);
    }
    makeFeathersPipeline(params) {
        const { filters, query } = this.filterQuery(null, params);
        const pipeline = [{ $match: query }];
        if (filters.$select !== undefined) {
            pipeline.push({ $project: this.getSelect(filters.$select) });
        }
        if (filters.$sort !== undefined) {
            pipeline.push({ $sort: filters.$sort });
        }
        if (filters.$skip !== undefined) {
            pipeline.push({ $skip: filters.$skip });
        }
        if (filters.$limit !== undefined) {
            pipeline.push({ $limit: filters.$limit });
        }
        return pipeline;
    }
    getSelect(select) {
        if (Array.isArray(select)) {
            if (!select.includes(this.id)) {
                select = [this.id, ...select];
            }
            return select.reduce((value, name) => ({
                ...value,
                [name]: 1
            }), {});
        }
        if (!select[this.id]) {
            return {
                ...select,
                [this.id]: 1
            };
        }
        return select;
    }
    async _findOrGet(id, params) {
        return id === null ? await this._find(params) : await this._get(id, params);
    }
    normalizeId(id, data) {
        if (this.id === '_id') {
            // Default Mongo IDs cannot be updated. The Mongo library handles
            // this automatically.
            return commons_1._.omit(data, this.id);
        }
        else if (id !== null) {
            // If not using the default Mongo _id field set the ID to its
            // previous value. This prevents orphaned documents.
            return {
                ...data,
                [this.id]: id
            };
        }
        return data;
    }
    async _get(id, params = {}) {
        const { query, filters: { $select } } = this.filterQuery(id, params);
        const projection = $select
            ? {
                projection: {
                    ...this.getSelect($select),
                    [this.id]: 1
                }
            }
            : {};
        const findOptions = {
            ...params.mongodb,
            ...projection
        };
        return this.getModel(params)
            .then((model) => model.findOne(query, findOptions))
            .then((data) => {
            if (data == null) {
                throw new errors_1.NotFound(`No record found for id '${id}'`);
            }
            return data;
        })
            .catch(error_handler_1.errorHandler);
    }
    async _find(params = {}) {
        const { paginate, useEstimatedDocumentCount } = this.getOptions(params);
        const { filters, query } = this.filterQuery(null, params);
        const useAggregation = !params.mongodb && filters.$limit !== 0;
        const countDocuments = async () => {
            if (paginate && paginate.default) {
                const model = await this.getModel(params);
                if (useEstimatedDocumentCount && typeof model.estimatedDocumentCount === 'function') {
                    return model.estimatedDocumentCount();
                }
                else {
                    return model.countDocuments(query, { ...params.mongodb });
                }
            }
            return Promise.resolve(0);
        };
        const [request, total] = await Promise.all([
            useAggregation ? this.aggregateRaw(params) : this.findRaw(params),
            countDocuments()
        ]);
        const page = {
            total,
            limit: filters.$limit,
            skip: filters.$skip || 0,
            data: filters.$limit === 0 ? [] : (await request.toArray())
        };
        return paginate && paginate.default ? page : page.data;
    }
    async _create(data, params = {}) {
        const writeOptions = params.mongodb;
        const model = await this.getModel(params);
        const setId = (item) => {
            const entry = Object.assign({}, item);
            // Generate a MongoId if we use a custom id
            if (this.id !== '_id' && typeof entry[this.id] === 'undefined') {
                return {
                    [this.id]: new mongodb_1.ObjectId().toHexString(),
                    ...entry
                };
            }
            return entry;
        };
        const promise = Array.isArray(data)
            ? model
                .insertMany(data.map(setId), writeOptions)
                .then(async (result) => model.find({ _id: { $in: Object.values(result.insertedIds) } }, params.mongodb).toArray())
            : model
                .insertOne(setId(data), writeOptions)
                .then(async (result) => model.findOne({ _id: result.insertedId }, params.mongodb));
        return promise.then((0, adapter_commons_1.select)(params, this.id)).catch(error_handler_1.errorHandler);
    }
    async _patch(id, _data, params = {}) {
        if (id === null && !this.allowsMulti('patch', params)) {
            throw new errors_1.MethodNotAllowed('Can not patch multiple entries');
        }
        const data = this.normalizeId(id, _data);
        const model = await this.getModel(params);
        const { query, filters: { $select } } = this.filterQuery(id, params);
        const updateOptions = { ...params.mongodb };
        const modifier = Object.keys(data).reduce((current, key) => {
            const value = data[key];
            if (key.charAt(0) !== '$') {
                current.$set = {
                    ...current.$set,
                    [key]: value
                };
            }
            else {
                current[key] = value;
            }
            return current;
        }, {});
        const originalIds = await this._findOrGet(id, {
            ...params,
            query: {
                ...query,
                $select: [this.id]
            },
            paginate: false
        });
        const items = Array.isArray(originalIds) ? originalIds : [originalIds];
        const idList = items.map((item) => item[this.id]);
        const findParams = {
            ...params,
            paginate: false,
            query: {
                [this.id]: { $in: idList },
                $select
            }
        };
        await model.updateMany(query, modifier, updateOptions);
        return this._findOrGet(id, findParams).catch(error_handler_1.errorHandler);
    }
    async _update(id, data, params = {}) {
        if (id === null || Array.isArray(data)) {
            throw new errors_1.BadRequest("You can not replace multiple instances. Did you mean 'patch'?");
        }
        const model = await this.getModel(params);
        const { query } = this.filterQuery(id, params);
        const replaceOptions = { ...params.mongodb };
        await model.replaceOne(query, this.normalizeId(id, data), replaceOptions);
        return this._findOrGet(id, params).catch(error_handler_1.errorHandler);
    }
    async _remove(id, params = {}) {
        if (id === null && !this.allowsMulti('remove', params)) {
            throw new errors_1.MethodNotAllowed('Can not remove multiple entries');
        }
        const model = await this.getModel(params);
        const { query, filters: { $select } } = this.filterQuery(id, params);
        const deleteOptions = { ...params.mongodb };
        const findParams = {
            ...params,
            paginate: false,
            query: {
                ...query,
                $select
            }
        };
        return this._findOrGet(id, findParams)
            .then(async (items) => {
            await model.deleteMany(query, deleteOptions);
            return items;
        })
            .catch(error_handler_1.errorHandler);
    }
}
exports.MongoDbAdapter = MongoDbAdapter;
//# sourceMappingURL=adapter.js.map